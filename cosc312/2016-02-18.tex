\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{xintexpr}
\usepackage{enumitem}

\newcommand{\T}{1}
\newcommand{\F}{0}
\newcommand{\TF}[1]{\if1#1\T\else\F\fi}
\newcommand{\xintTF}[1]{\xintifboolexpr{#1}{\T}{\F}}

\newcommand{\logicrule}[2]{
\begin{array}{l}
#1 \\
\midrule
\therefore #2 \\
\end{array}
}

\newcommand{\inv}[1]{#1^{-1}}

\renewcommand{\d}[1]{\,\textnormal{d}#1}
\newcommand{\dd}[2]{\frac{\d{#1}}{\d{#2}}}
\newcommand{\ddd}[2]{\dfrac{\d{#1}}{\d{#2}}}

\DeclareMathOperator{\var}{Var}
\DeclareMathOperator{\E}{\mathcal{E}}

\newcommand{\multistep}[1]{\begin{array}{rl} #1 \end{array}}
\newcommand{\subeq}{\subseteq}
\newcommand{\sub}{\subset}

\newcommand{\conj}[1]{\overline{#1}}

\setlength\parindent{0pt}
\setlength\parskip{1em}

\begin{document}

\section*{Chomsky Normal Form}

This is a way to simplify CFGs into CNF.

Every rule in the grammar has the form:

\[
\begin{cases}
A\rightarrow B C \\
A \rightarrow a
\end{cases}
\]

where $A,B,C$ are non terminals, and $a$ is a terminal.

The rule $S\rightarrow\epsilon$ is \textbf{not excluded}.

\subsection*{Theorem}

Any CFL is generated by a CFG in CNF.

\begin{enumerate}
\item Add a new starting symbol $S_0$ and rule $S_0\rightarrow{}S$,
  where $S$ is the original starting symbol. (We don't want S on the
  right hand side of any rule).

\item Eliminate $\epsilon$-rules by repeating until all $\epsilon$-rules are removed:
  \begin{enumerate}[label=(\alph*)]
    \item Eliminate the $\epsilon$-rule $A\rightarrow\epsilon$, where
      $A$ is not the start symbol.

    \item For each occurrence of $A$ on the right hand side of any
      rule, add a new rule with that occurrence of $A$ deleted. For
      example: To delete $A\rightarrow\epsilon$, replace
      $B\rightarrow{}uAv$ by $B\rightarrow{}uAv|uv$.

    \item Replace the rule $B\rightarrow{}A$ (if it is present) with
      $B\rightarrow{}A|\epsilon$.
  \end{enumerate}

\item Remove unit rules. Repeat until all unit rules are removed:
  \begin{enumerate}[label=(\alph*)]
  \item Remove rule $A\rightarrow{}B$

  \item For each rule $B\rightarrow{}U$ that appears, add the rule
    $A\rightarrow{}U$.
  \end{enumerate}

\item Convert remaining rules. Repeat until no rules of the form
  $A\rightarrow{}U_1U_2\cdots{}U_k$ for $k\ge3$:

  \begin{enumerate}[label=(\alph*)]
  \item Replace a rule $A\rightarrow{}U_1U_2\cdots{}U_k$ for $k\ge3$
    with the rules:

    \[\begin{cases}
      A\rightarrow U_1A_1 \\ A_1\rightarrow{}U_2A_2 \\ \vdots \\ A_{k-2}\rightarrow{}U_{k-1}U_{k}
    \end{cases}\]

  \item If $k\ge2$, replace each terminal $u_k$ with new variable
    $U_k\rightarrow{}u_k$
  \end{enumerate}
\end{enumerate}

\section*{Example of CFG $\rightarrow$ CNF}

Given the rules:

\[\begin{cases}
S\rightarrow ASA|aB \\
A\rightarrow B|S \\
B\rightarrow b|\epsilon \\
\end{cases}\]

\begin{enumerate}[label=(Step \arabic*)]
\item Introduce new start state

\[\begin{cases}
S_0 \rightarrow S \\
S\rightarrow ASA|aB \\
A\rightarrow B|S \\
B\rightarrow b|\epsilon \\
\end{cases}\]

\item Remove $\epsilon$-rules.

  \begin{enumerate}[label=(\alph*)]
  \item Remove $B\rightarrow{}\epsilon$

    \[\begin{cases}
    S_0 \rightarrow S \\
    S\rightarrow ASA|aB|a \\
    A\rightarrow B|S|\epsilon \\
    B\rightarrow b \\
    \end{cases}\]

  \item Remove $A\rightarrow\epsilon$

    \[\begin{cases}
    S_0 \rightarrow S \\
    S\rightarrow ASA|aB|a|AS|SA|S \\
    A\rightarrow B|S \\
    B\rightarrow b \\
    \end{cases}\]
  \end{enumerate}

\item Remove unit rules

  \begin{enumerate}[label=(\alph*)]
  \item Remove $S\rightarrow{}S$

    \[\begin{cases}
    S_0 \rightarrow S \\
    S\rightarrow ASA|aB|a|AS|SA \\
    A\rightarrow B|S \\
    B\rightarrow b \\
    \end{cases}\]

  \item Remove $S_0\rightarrow{}S$

    \[\begin{cases}
    S_0 \rightarrow ASA|aB|a|AS|SA \\
    S\rightarrow ASA|aB|a|AS|SA \\
    A\rightarrow B|S \\
    B\rightarrow b \\
    \end{cases}\]

  \item Remove $A\rightarrow{}B$

    \[\begin{cases}
    S_0 \rightarrow ASA|aB|a|AS|SA \\
    S\rightarrow ASA|aB|a|AS|SA \\
    A\rightarrow S|b \\
    B\rightarrow b \\
    \end{cases}\]

  \item Remove $A\rightarrow{}S$

    \[\begin{cases}
    S_0 \rightarrow ASA|aB|a|AS|SA \\
    S\rightarrow ASA|aB|a|AS|SA \\
    A\rightarrow b|ASA|aB|a|AS|SA \\
    B\rightarrow b \\
    \end{cases}\]

  \end{enumerate}

\item Convert remaining rules

  \begin{enumerate}[label=(\alph*)]
  \item Clean up $ASA$

    \[\begin{cases}
    S_0 \rightarrow AA_1|aB|a|AS|SA \\
    S\rightarrow AA_1|aB|a|AS|SA \\
    A\rightarrow b|AA_1|aB|a|AS|SA \\
    B\rightarrow b \\
    A_1\rightarrow SA \\
    \end{cases}\]

  \item Clean up $aB$

    \[\begin{cases}
    S_0 \rightarrow AA_1|UB|a|AS|SA \\
    S\rightarrow AA_1|UB|a|AS|SA \\
    A\rightarrow b|AA_1|aB|a|AS|SA \\
    B\rightarrow b \\
    A_1\rightarrow SA \\
    U\rightarrow a
    \end{cases}\]

  \end{enumerate}
\end{enumerate}

\section*{$LL(1)$ Grammar Example}

We want to write an $LL(1)$ grammar for a lanugage of prperly balanced
parentheses and brackets.

\begin{enumerate}[label=\arabic*)]
\item $P\rightarrow{}S\$\$$
\item $S\rightarrow (S)S$
\item $S\rightarrow [S]S$
\item $S\rightarrow\epsilon$
\end{enumerate}

To work with this, we use a parse table which relates a top of a stack
and the current input token:

\begin{tabular}{r|ccccc}
Top of Stack & Token & & & \\
 & $($ & $)$ & $[$ & $]$ & $\$\$$ \\
\hline
P & 1 & - & 1 & - & 1 \\
S & 2 & 4 & 3 & 4 & 4 \\
\end{tabular}

\subsection*{Parsing}

\begin{tabular}{l|r|l}
Stack & Input Stream & Comment \\
\hline
$P$ & $([]([]))[](())\$\$$ & \\
$S\$\$$ & $([]([]))[](())\$\$$ & Predict $P\rightarrow{}S\$\$$ \\
$(S)S\$\$$ & $([]([]))[](())\$\$$ & Predict $P\rightarrow{}(S)S$ \\
$S)S\$\$$ & $[]([]))[](())\$\$$ & Match $($ \\
$[S])S\$\$$ & $[]([]))[](())\$\$$ & Predict $S\rightarrow[S]S$ \\
$S])S\$\$$ & $]([]))[](())\$\$$ & Match $[$ \\
$])S\$\$$ & $]([]))[](())\$\$$ & Predict $S\rightarrow\epsilon$ \\
$\vdots$ & $\vdots$ & $\vdots$ \\
$\$\$$ & $\$\$$ & Predict $S\rightarrow\epsilon$ \\
& & Match $\$\$$ \\
\end{tabular}


\end{document}
